\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{biblatex}
\addbibresource{refs.bib}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\title{Relazione di Tirocinio\\``Analisi di vulnerabilità nelle API REST e configurazione di un ambiente di test con strumenti OWASP''}

\author{Grimaldi Leonardo\\\href{mailto:leonardo.grimaldi2@studio.unibo.it}{leonardo.grimaldi2@studio.unibo.it}}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduzione}
Le vulnerabilità web sono tra le più comuni e pericolose minacce alla sicurezza informatica. Esse possono essere sfruttate da attaccanti per compromettere la riservatezza, l'integrità e la disponibilità dei dati e dei sistemi. Nel corso del tirocinio sono state studiate ed analizzate diverse vulnerabilità tra cui XSS (Cross-Site Scripting), Injection e Broken Access Control. L'analisi è stata condotta utilizzando come target l'applicazione web OWASP Juice Shop, mentre per gli strument di test sono stati utilizzati OWASP ZAP, Postman e Chrome DevTools.
\par
Nella fase iniziale si è condotto un lavoro di analisi dell'applicazione per comprendere il suo funzionamento e individuare le aree potenzialmente vulnerabili. Successivamente, sono stati eseguiti test specifici per ogni vulnerabilità, documentando i risultati ottenuti.
\section{Strumenti utilizzati}
\subsection{Browser DevTools}
Il primo è più importante strumento che è stato utilizzato è lo strumento di sviluppo integrato nei browser web come Chrome e Firefox. Per entrambi, la scorciatoia di apertura sono i tasti \texttt{CTRL + SHIFT + I}. La loro utilità si trova nelle finestre \textit{Console}, \textit{Elements}, \textit{Sources}, \textit{Network}.
\subsubsection{Console}
La console registra i messaggi di log, gli errori e gli avvisi generati dalla pagina web. È possibile eseguire comandi JavaScript direttamente nella console per testare il comportamento della pagina. Nell'esecuzione di codice lato cliente può accadere che alcune chiamate API restituiscano errore; visualizzarli in console costituisce un primo sopralluogo dell'applicazione.
\subsubsection{Elements (Inspector su Firefox)}
La scheda elementi (figura \ref{fig:chrome-dev-tools-elements} e \ref{fig:api-products-devtools}) mostra l'albero DOM\cite{mdn-dom} della pagina HTML. Consente di ispezionare e modificare gli elementi HTML e i loro stili CSS in tempo reale. Nell'analisi delle vulnerabilità si può trovare utile modificare attributi per consentire operazioni sull'interfaccia grafica (vedi \ref{fig:complaint-form-allowed-extensions}). Inoltre questa visualizzazione consente facilmente di saltare negli \textit{event listener} associati ad un elemento come i bottoni, per analizzare il codice JavaScript e cercare endpoint API.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/chrome-dev-tools-elements.png}
\caption{Finestra \textit{Elements} dei developer tools. Lo spazio a sinistra mostra l'albero degli elementi mentre a destra si trovano gli \textit{Event Listeners} e altre schermate debug per \textit{CSS}}
\label{fig:chrome-dev-tools-elements}
\end{figure}
\subsubsection{Sources (Debugger su Firefox)}
Nella schermata di figura \ref{fig:chrome-dev-tools-sources} si visualizzano i file \texttt{.js} ai quali la pagina fa riferimento. Contiene il codice eseguito lato client.e quindi gli \textit{event listener} accennati nel punto precedente. Si rivela molto utile (soprattutto per siti \textit{React} e \textit{Angular} che sono \textit{JS-heavy}) per la raccolta di informazioni poiché essa contiene chiamate \textit{API} e molto spesso commenti degli sviluppatori o chiavi importanti che consentono il sorpasso delle autorizzazioni (\textbf{privilege escalation}).
\par
Un altro utilizzo importante è lo \textbf{script overriding}. Abilitando alcune impostazioni e assegnando una cartella si può configurare il sito per eseguire codice \textit{JavaScript} modificato localmente a proprio piacere.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/chrome-dev-tools-sources.png}
\caption{Finestra \textit{Sources} con tre suddivisioni: A sinistra i file necessari per l'esecuzione lato client del sito, al centro i singoli file aperti (il bollino viola accanto a \texttt{main.js} indica lo script override) e a destra il debugger \textit{JavaScript}}
\label{fig:chrome-dev-tools-sources}
\end{figure}
\subsubsection{Network}
Le richieste al server e le risposte vengono collocate nella finestra \textit{Network} che costituisce quindi uno strumento molto potente per il testing di sicurezza. Si può intendere come una versione minimale di \textit{ZAP} che consente di vedere gli \textit{Header}, \textit{Request} e \textit{Response} dei pacchetti HTTP. Tuttavia non lo sostituisce interamente poiché la funzionalità di intercettazione con \textit{Proxy} di \textit{ZAP} rivela molte più richieste.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/chrome-dev-tools-network.png}
\caption{Finestra \textit{Network} con il grafico dei tempi di richesta, la lista di richieste (login evidenziato) e il Payload}
\label{fig:chrome-dev-tools-network}
\end{figure}
\subsubsection{Chrome vs Firefox DevTools}
L'intefaccia di Chrome DevTools si presenta più moderna e curata rispetto a Firefox. Tuttavia, quest'ultimo offre alcune funzionalità aggiuntive che lo rendono più adatto per il testing di sicurezza. Ad esempio, Firefox consente di modificare gli \textit{Header} delle richieste direttamente dalla scheda \textit{Network} (Figura \ref{fig:firefox-dev-tools-network}), mentre in Chrome è necessario utilizzare estensioni di terze parti. Inoltre, Firefox offre una migliore integrazione con strumenti di sicurezza come \textit{ZAP} e \textit{Burp Suite}.
\par
In più, su Firefox DevTools è molto più facile trovare il riferimento al codice \textit{JavaScript} per un elemento \textit{HTML}.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/firefox-dev-tools-network.png}
\caption{Creazione di una nuova richiesta su Firefox partendo da una già fatta}
\label{fig:firefox-dev-tools-network}
\end{figure}
\chapter{XSS (Cross-Site Scripting)}
\section{Descrizione}
https://owasp.org/www-community/attacks/xss/
\par
Il Cross-Site Scripting (XSS) è una vulnerabilità web che consente di lanciare script maliziosi sul browser della vittima che accede a un sito leggittimo. Per fare ciò un attaccante può sfruttare diversi metodi tra cui URL manipolati e campi di input non validati.
\par
Gli attacchi XSS possono essere classificati in tre categorie principali:
\begin{itemize}
    \item Reflected XSS: lo script malizioso viene caricato come parte della risposta del server 
    \item Stored XSS: lo script malizioso viene memorizzato sul server (ad esempio in un database) e viene eseguito quando un utente accede alla risorsa compromessa
    \item DOM-based XSS: lo script malizioso viene eseguito a causa di modifiche al DOM\cite{mdn-dom} nel browser della vittima, senza fare richiesta al server
\end{itemize}
\section{Contromisure}
Per prevenire gli attachi XSS è necessario sanare e validare tutti i dati in input provenienti dagli utenti, sia URL che form. Le metodologie di sviluppo moderne come i framework web ne consentono la mitigazione implementando misure di sicurezza che automaticamente eseguono la sanificazione. Perciò per comprendere bene le potenziali falle di sicurezza è necessario conoscere accuratamente le chiamate dei framework utilizzati. Inoltre, bisogna prestare attenzione all'utilizzo di funzioni che esegono il \textit{bypass} delle misure di sicurezza come \texttt{bypassSecurityTrust}\cite{angular-domsanitizer} di \textit{Angular}. 
\section{DOM XSS} \label{dom-xss}
La pagina iniziale presenta una barra di ricerca che non sanifica l'input dell'utente. Per provare ciò occorre inserire nella barra di ricerca il seguente codice \texttt{<h1>Test<h1>}, eseguire la ricerca e analizzare la pagina modificata (senza interazione con il server) per trovare l'elemento inserito all'interno del DOM. L'immagine \ref{fig:dom-xss-probing} mostra il successo di questo test aprendo la strada per un attacco XSS.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/dom-xss-probing.png}
\caption{Probing della barra di ricerca con tag \textit{HTML} \texttt{<h1>}. L'\textit{ispeziona elementi} mostra la presenza del tag nell'albero della pagina suggerendo una possibile vulnerabilità.}
\label{fig:dom-xss-probing}
\end{figure}
Escogito un payload diverso che sfrutta questa vulnerabilità per eseguire uno script \textit{JavaScript}, che nella realtà si connetterrebbe a un server controllato dall'attaccante per rubare i dati dell'utente. Immetto nella barra di ricerca il seguente codice: \texttt{<script>alert(xss)</script>}, ma non verifico la sua esecuzione. Ciò è dovuto presumibilmente al fatto che lo standard \textit{HTML5} non consente l'esecuzione di tag \texttt{<script>} inseriti con \textit{innerHTML}\cite{innerHTML}.
\par
Tento un payload alternativo che utilizza il tag \texttt{<iframe>} per caricare codice esterno: \texttt{<iframe src="javascript:alert(`xss`)">}. In questo modo, il codice viene eseguito correttamente come mostrato in figura \ref{fig:dom-xss-result}. Verificando questa vulnerabilità, l'attacante può scegliere di inviare link appositamente creati alle vittime per eseguire codice malevolo nei loro browser da una fonte attendibile come il sito web compromesso. Essendo inoltre una vulnerabilità basata sul DOM, il server non ha modo di rilevare l'attacco.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/dom-xss-result-small.png}
\caption{Risultato di esecuzione del script malizioso contenuto dentro un tag \texttt{<iframe>}. L'alert dimostra che il codice è stato eseguito con successo.}
\label{fig:dom-xss-result}
\end{figure}
\chapter{Injection}
\href{https://owasp.org/Top10/2025/A05_2025-Injection/}{OWASP TOP 10 (2025) - Injection}\cite{injection-owasp}
\section{Descrizione}
I web server utilizzano ampiamente database per memorizzare e recuperare dati. Un attacco di tipo Injection si verifica quando un attaccante riesce a inserire comandi all'interno di una query SQL, permettendo così di manipolare il database in modi non previsti. Esistono tre tipologie di attacchi Injection:
\begin{description}
    \item[Inband] La richiesta e la risposta avvengono attraverso lo stesso canale di comunicazione
    \item[Out-of-band] La risposta avviene attraverso un canale diverso rispetto alla richiesta (ad esempio tramite email)
    \item[Inferential] La risposta viene dedotta osservando il comportamento del server (ad esempio tempi di risposta diversi)
\end{description}
\section{Contromisure}
Gli attachi Injection si possono prevenire utilizzando le chiamate API sicure offerte dall'interfaccia con il database (al posto di costruire stringhe query dinamicamente), come i \textit{prepared statements} di PHP. È indispensabile inoltre validare correttamente l'input ed eliminare caratteri speciali che potrebbero compromettere la query. 
\section{Database Schema}
Per ottenere lo schema del database l'attenzione è stata posta sulla barra di ricerca dei prodotti. Si è tentato un payload iniziale semplice come \texttt{' OR 1=1--} che però non ha prodotto risultati poiché la ricerca è lato client come visto in \ref{dom-xss}. Occorre perciò intercettare la richiesta API che recupera i prodotti dal database utilizzando \textit{ZAP}. La \ref{fig:api-search-request} mostra che il browser fa richiesta a \texttt{/rest/products/search?q=} per ottenere la lista dei prodotti da visualizzare. Navigando sull'URL se ne può avere conferma. Si sfrutta il parametro \texttt{q} per eseguire lo stesso payload di prima: il riscontro è un errore \texttt{SQLITE\_ERROR: incomplete input}. Questo errore conferisce un duplice risultato: il payload è stato iniettato correttamente nella query SQL e il database utilizzato è \textbf{SQLite}.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/api-search-request.png}
\caption{Richiesta API per la ricerca dei prodotti evidenziata in blu nella finestra inferiore. In alto la risposta del server contenente i header e il JSON dei prodotti (giallo e rosa)}
\label{fig:api-search-request}
\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/api-search-incomplete-input-2.png}
\caption{Pagina di errore restituita dal server in seguito al payload di injection \texttt{' OR true--} su \texttt{/rest/products/search?q=}. L'errore indica che la query SQL non è stata completata correttamente a causa del payload inserito.}
\label{fig:api-search-incomplete-input}
\end{figure}
Per poter eseguire ulteriori injection è necessario conoscere la query che viene eseguita dal server. Rispetto alle vecchie versioni di \textit{Juice Shop}, la versione attuale non espone più le query SQL complete negli errori. Si cerca quindi su internet la query utilizzata, ma si può benissimo tentare di scoprirla con \textit{sqlmap}\cite{sqlmap}. \texttt{SELECT * FROM Products WHERE ((name LIKE ‘\%payload\%’ OR description LIKE ‘\%payload\%’) AND deletedAt IS NULL) ORDER BY name}.
\par
Dalla query possiamo capire il meccanismo di sostituzione del parametro \texttt{q} che viene iniettato e costruire il payload partendo con i caratteri \texttt{'))}. Essendo una query di selezione, sarà necessario appendere l'operatore \texttt{UNION} per ottenere il risultato della injection dentro la risposta del \texttt{SELECT}\cite{injection-union-attack}.
\par
Il passo successivo è quello di scoprire le tabelle del database. Ricercando su internet si trova che la query per ottenere i nomi delle tabelle in SQLite è: \texttt{SELECT sql FROM sqlite\_schema}\cite{sqlite-schema-query}. Ricomponendo i payload precedentemente descritti, il payload finale diventa: \texttt{')) UNION SELECT sql FROM sqlite\_master--}. Ora però si tenta di esegurilo via browser, ma il server restituisce l'errore illustrato in figura \ref{fig:api-search-schema-fail}.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/api-search-schema-fail.png}
\caption{Errore restituito dal server in seguito al payload di injection per ottenere lo schema del database. L'errore indica che il numero di colonne restituite dalla query \texttt{UNION} non corrisponde a quello della query originale.}
\label{fig:api-search-schema-fail}
\end{figure}
Per comprendere questo, è necessario sapere il funzionamento della \texttt{UNION}. Essa richiede che il numero di colonne restituite dalle due query sia lo stesso. Dalla query originale sappiamo che vengono restituite tutte le colonne della tabella \texttt{Products}, ma non sappiamo quante sono. Per scoprirlo si può procedere a tentativi e aggiungere colonne al payload finché non si ottiene una risposta valida. Il payload diventa quindi: \texttt{')) UNION SELECT sql,2,3,4,5,6,7,8,9 FROM sqlite\_master--} e si ottiene lo schema del database \ref{fig:api-search-schema-success}.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/api-search-schema-success.png}
\caption{Risposta JSON contenente lo schema del database in seguito al payload di injection corretto con il numero giusto di colonne.}
\label{fig:api-search-schema-success}
\end{figure}
\chapter{Broken Access Control}
\href{https://owasp.org/Top10/2025/A01_2025-Broken_Access_Control/}{OWASP TOP 10 (2025) - Broken Access Control}\cite{broken-access-control-owasp}
\section{Descrizione}
Il controllo degli accessi errato è la vulnerabilità più diffusa che prende il primo posto nella lista delle 10 vulnerabilità più diffuse di OWASP\cite{broken-access-control-owasp}. Essa coinvolge principalmente le pagine e servizi nascosti dietro una pagina di autenticazione come login utente, amministratore, ma anche chiamate API che vengono eseguite nel contesto dell'applicazione. Esistono svariati vettori di attacco, ma i principali coinvolgono la modifica di richieste API, identificatori (come parametri GET negli URL, esempio: \texttt{/utente?id=1234}).
\section{Contromisure}
Il punto iniziale per mettere in sicurezza le pagine riservate (i.e. non disponibili al pubblico) è di negare ogni richiesta. Successivamente, implementare un meccanismo di autenticazione che viene replicato su \textit{tutte} le pagine private. L'accesso deve essere consentito in base al ruolo (Role-Based Access Control - RBAC), attribuendo i minimi privilegi necessari per eseguire le operazioni richieste. Infine, è importante monitorare e registrare tutte le attività sospette per rilevare eventuali tentativi di accesso non autorizzato. Implementare il \textit{rate-limiting} per prevenire attacchi di forza bruta.
\section{Product Tampering}
Scorrendo nel codice \textit{JavaScript} \texttt{main.js} del sito web è possibile trovare con grande facilità le API utilizzate per gestire i prodotti. Una di queste è \texttt{/api/Products} (Figura \ref{fig:api-products-devtools}). Si presuppone che l'endpoint venga utilizzato dagli amministratori per creare o modificare i prodotti, ma presto si vedrà che è possibile farne uso senza autenticazione.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/api-products-devtools.png}
\caption{Codice \textit{JavaScript} che mostra l'uso dell'endpoint \texttt{/api/Products} visualizzato nei strumenti di sviluppo del browser.}
\label{fig:api-products-devtools}
\end{figure}
Visitando l'endpoint API in questione vengono mostrati in formato JSON tutti i prodotti. Aggiungendo l'id di un prodotto: \texttt{/api/Products/9} è possibile interagire con il singolo prodotto. In HTTP si hanno diversi metodi di richiesta tra cui \texttt{GET}, \texttt{POST}, \texttt{PUT} e \texttt{DELETE}. Utilizzando \textit{Postman} si può inviare una richiesta di tipo \texttt{PUT} per modificare il prodotto con id 9 (Figura \ref{fig:api-products-put}). Nella richiesta si specifica la nuova descrizione del prodotto e si invia la richiesta senza nessun header di autenticazione. La risposta del server è positiva (codice 200) e il prodotto viene modificato con successo.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/api-products-put.png}
\caption{Esecuzione con \textit{Postman} di una richiesta \texttt{PUT} sull'endpoint \texttt{/api/Products/9} per modificare il prodotto con id 9 senza autenticazione. La risposta del server (in basso) indica che la modifica è avvenuta con successo.}
\label{fig:api-products-put}
\end{figure}
\chapter{Security Misconfiguration}
\href{https://owasp.org/Top10/2025/A02_2025-Security_Misconfiguration/}{OWASP TOP 10 (2025) - Security Misconfiguration}\cite{security-misconfiguration-owasp}
\section{Descrizione}
Le configurazione errata delle applicazioni si trova al secondo posto della lista \textit{OWASP TOP 10}. Essa si verifica quando le impostazioni di sicurezza non sono configurate correttamente o sono lasciate ai valori predefiniti. Ciò può includere configurazioni errate del server web, del database, del sistema operativo o dell'applicazione stessa. In aggiunta, la comunicazione di messaggi di errore dettagliati agli utenti finali può rivelare informazioni sensibili che possono essere sfruttate dagli attaccanti.
\section{Contromisure}
Integrare nel contesto CI/CD i controlli sulle configurazioni. Cambiare le credenziali di accesso predefinite e revisionare le configurazioni. Evitare di esporre messaggi di errore e disabilitare le funzionalità non necessarie.
\section{Deprecated Interface}
Dopo aver eseguito il login con un account personale è possibile vedere il link alla pagina \textit{Complaint} nella barra laterale (\texttt{/complain}). Visitandola si è presentati con un form \ref{fig:complaint-form} contenente i campi \textit{Customer} (non modificabile), \textit{Message*} e \textit{Invoice}, il quale consente di allegare un file opzionale. Il vettore di attacco è esattamente quest'ultimo, su cui verranno controllate le restrizioni di upload.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/complaint-form.png}
\caption{Form di invio reclami con campo di caricamento file.}
\label{fig:complaint-form}
\end{figure}
Premendo su \texttt{Sfoglia...} si apre l'esplora file del sistema operativo che consente di allegare i file. Su \textit{Windows} la finestra esplora file consente di filtrare le estensioni consentite nel menù a scelta in basso a destra. Tuttavia, è possibile visualizzare le stesse nel \textit{HTML} della pagina con l'ispeziona elementi. L'attributo \textit{accept} della figura \ref{fig:complaint-form-allowed-extensions} mostra le estensioni consentite \texttt{.pdf} e \texttt{.zip} lato client. Ovviamente, essendo solo un controllo locale, è possible che questo non venga effettuato sul server.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/complaint-form-allowed-extensions.png}
\caption{Elemento \texttt{input} del form di invio reclami che mostra le estensioni consentite per gli allegati.}
\label{fig:complaint-form-allowed-extensions}
\end{figure}
È saggio tentare di allegare un file con estensione arbitraria per verificare se il server accetta estensioni diverse da quelle elencate:
\begin{figure}[H]
\centering
\includegraphics{images/complaint-form-forbidden-file-type.png}
\caption{Violazione degli allegati consentiti dopo aver inserito un immagine \texttt{.jpg} nel form di invio reclami.}
\label{fig:complaint-form-forbidden-file-type}
\end{figure}
Tentando dall'interfaccia grafica si riscontra l'errore \ref{fig:complaint-form-forbidden-file-type} che rende difficile procedere. In questi casi si decide di proseguire con \textit{ZAP} e intercettare una richiesta di invio del form pulita. Si crea quindi un file \texttt{prova.zip}, lo si allega al form con il commento e si invia la richiesta.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/complaint-form-zap-upload-prova.png}
\caption{Intercettazione con \textit{ZAP} di una richiesta pulita con allegato \texttt{prova.zip} visibile nel attributo \texttt{filename=""} del corpo della richiesta.}
\label{fig:complaint-form-zap-upload-prova}
\end{figure}
La richiesta intercettata da \textit{ZAP} mostra chiaramente l'API di upload \texttt{/file-upload}, il metodo \texttt{POST} e il file allegato \texttt{prova.zip} e il codice di stato \texttt{204} che ne indica il successo. Si procede quindi nel \textit{Request Editor} di \textit{ZAP} per modificare il file allegato con uno di tipo non consentito, ad esempio \texttt{.txt} nel corpo della richiesta.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/complaint-form-zap-upload-text.png}
\caption{.}
\label{fig:complaint-form-zap-upload-text}
\end{figure}
Cliccando su \textit{Send} la richiesta modificata viene inviata al server. La risposta del server è nuovamente un \texttt{HTTP 204 code} e il file viene caricato con successo nonostante la violazione delle estensioni consentite. Ciò dimostra che il controllo delle estensioni è effettuato solo lato client e non sul server, permettendo così a un attaccante di caricare file arbitrari.
\par
Il passaggio finale per scovare l'interfaccia deprecata è quello di analizzare il codice \textit{JavaScript} del sito web. Cercando la parola chiave \texttt{file-upload} si trova facilmente la funzione che gestisce l'upload dei file \ref{fig:file-upload-main-js}. Al suo interno si nota il vettore \texttt{allowedMimeType} che consente l'upload di file \texttt{.xml} e \texttt{.yaml} oltre a quelli visti in precedenza.
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/file-upload-main-js.png}
\caption{Codice \texttt{JavaScript} che gestisce l'upload dei file nel sito web. Si notano le estensioni consentite lato client tra cui \texttt{.xml} e \texttt{.yaml}.}
\label{fig:file-upload-main-js}
\end{figure}
Più avanti nel codice, si legge la stringa \texttt{Input area for uploading a single invoice PDF or XML B2B order file or a ZIP archive containing multiple invoices or orders<!---->} che conferma la presenza di un'interfaccia deprecata per l'upload di file \texttt{.xml}.
\par
Avendo ora la certezza dell'esistenza di questa interfaccia, si procede a caricare un file \texttt{.xml} arbitrario tramite \textit{ZAP} come fatto in precedenza. La risposta del server è positiva e il file viene caricato con successo.
\chapter{Conclusioni}
Le vulnerabilità web sono molto diffuse e spesso facili da sfruttare. Derivano principalmente da un uso erroneo delle tecnologie web e da una scarsa conoscenza delle misure di sicurezza da adottare.
\printbibliography
\end{document}